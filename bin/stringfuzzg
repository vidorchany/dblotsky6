#!/usr/bin/env python3

'''
The fuzzer tool that generates new problems.
'''

import sys
import argparse
import random

from stringfuzz.constants import LANGUAGES, SMT_20_STRING, SMT_25_STRING
from stringfuzz.parser import parse
from stringfuzz.generator import generate
from stringfuzz.smt import smt_model
from stringfuzz.generators import concats, overlaps, lengths, random_text, random_ast, regex_pair, SYNTACTIC_DEPTH, SEMANTIC_DEPTH

# constants
CONCATS     = 'concats'
LENGTHS     = 'lengths'
OVERLAPS    = 'overlaps'
RANDOM_TEXT = 'random-text'
RANDOM_AST  = 'random-ast'
REGEX_PAIR  = 'regex-pair'

GENERATORS = {
    CONCATS:     concats,
    LENGTHS:     lengths,
    OVERLAPS:    overlaps,
    RANDOM_TEXT: random_text,
    RANDOM_AST:  random_ast,
    REGEX_PAIR:  regex_pair,
}

DEPTH_TYPES = [SYNTACTIC_DEPTH, SEMANTIC_DEPTH]

# defaults
DEFAULT_SEED           = 0
DEFAULT_RANDOM         = False
DEFAULT_PRODUCE_MODELS = False

DEFAULT_LENGTH           = 10
DEFAULT_DEPTH            = 5
DEFAULT_SOLUTION         = None
DEFAULT_BALANCED         = False
DEFAULT_RANDOM_RELATIONS = False
DEFAULT_DEPTH_TYPE       = SYNTACTIC_DEPTH
DEFAULT_EXTRACTED        = 0
DEFAULT_EXTRACT_INDEX    = 10

DEFAULT_NUM_VARS    = 5
DEFAULT_MIN_LEN     = 0
DEFAULT_MAX_LEN     = 10
DEFAULT_NUM_CONCATS = 0

DEFAULT_NUM_OVERLAPPING  = 2
DEFAULT_LENGTH_OF_CONSTS = 5

def main():

    # create arg parser
    global_parser = argparse.ArgumentParser(description='SMTLIB 2.* problem generator.')

    # global args
    global_parser.add_argument(
        '--language',
        '-l',
        dest    = 'language',
        type    = str,
        choices = LANGUAGES,
        default = SMT_25_STRING,
        help    = 'output language (default: {})'.format(SMT_25_STRING)
    )
    global_parser.add_argument(
        '--models',
        '-m',
        dest    = 'produce_models',
        action  = 'store_true',
        default = DEFAULT_PRODUCE_MODELS,
        help    = 'append the SMT 2.x command to produce a model (default: {})'.format(DEFAULT_PRODUCE_MODELS)
    )
    seed_group = global_parser.add_mutually_exclusive_group()
    seed_group.add_argument(
        '--seed',
        '-s',
        dest    = 'seed',
        metavar = 'S',
        type    = int,
        default = DEFAULT_SEED,
        help    = 'seed for random number generator (default: {})'.format(DEFAULT_SEED)
    )
    seed_group.add_argument(
        '--random',
        '-r',
        dest    = 'random',
        action  = 'store_true',
        default = DEFAULT_RANDOM,
        help    = 'seed the random number generator with the current time (default: {})'.format(DEFAULT_RANDOM)
    )

    # get subparsers
    subparsers = global_parser.add_subparsers(dest='generator', help='generator choice')
    subparsers.required = True

    # concats fuzzer
    concats_parser = subparsers.add_parser(CONCATS, help='instance with deeply nested concats')
    concats_parser.add_argument(
        '--depth',
        '-d',
        dest    = 'depth',
        metavar = 'D',
        type    = int,
        default = DEFAULT_DEPTH,
        help    = 'depth of the concats (default: {})'.format(DEFAULT_DEPTH)
    )
    concats_parser.add_argument(
        '--depth-type',
        '-t',
        dest    = 'depth_type',
        type    = str,
        choices = DEPTH_TYPES,
        default = DEFAULT_DEPTH_TYPE,
        help    = 'type of depth (default: {})'.format(DEFAULT_DEPTH_TYPE)
    )
    concats_parser.add_argument(
        '--solution',
        '-s',
        dest    = 'solution',
        metavar = 'S',
        type    = str,
        default = DEFAULT_SOLUTION,
        help    = 'expected solution (default: {!r})'.format(DEFAULT_SOLUTION)
    )
    concats_parser.add_argument(
        '--extract',
        '-e',
        dest    = 'num_extracts',
        metavar = 'N',
        type    = int,
        default = DEFAULT_EXTRACTED,
        help    = 'number of extracts to add (default: {})'.format(DEFAULT_EXTRACTED)
    )
    concats_parser.add_argument(
        '--extract-max',
        '-m',
        dest    = 'max_extract_index',
        metavar = 'N',
        type    = int,
        default = DEFAULT_EXTRACT_INDEX,
        help    = 'max index from which to extract (default: {})'.format(DEFAULT_EXTRACT_INDEX)
    )
    concats_parser.add_argument(
        '--balanced',
        '-b',
        action  = 'store_true',
        default = DEFAULT_BALANCED,
        help    = 'flag for balanced tree (default: {!r})'.format(DEFAULT_BALANCED)
    )

    # lengths fuzzer
    lengths_parser = subparsers.add_parser(LENGTHS, help='instance with length constraints')
    lengths_parser.add_argument(
        '--num-vars',
        '-v',
        dest    = 'num_vars',
        metavar = 'N',
        type    = int,
        default = DEFAULT_NUM_VARS,
        help    = 'number of variables to create (default: {})'.format(DEFAULT_NUM_VARS)
    )
    lengths_parser.add_argument(
        '--min-length',
        '-n',
        dest    = 'min_length',
        metavar = 'N',
        type    = int,
        default = DEFAULT_MIN_LEN,
        help    = 'lower bound on length (default: {})'.format(DEFAULT_MIN_LEN)
    )
    lengths_parser.add_argument(
        '--max-length',
        '-x',
        dest    = 'max_length',
        metavar = 'N',
        type    = int,
        default = DEFAULT_MAX_LEN,
        help    = 'upper bound on length (default: {})'.format(DEFAULT_MAX_LEN)
    )
    lengths_parser.add_argument(
        '--num-concats',
        '-c',
        dest    = 'num_concats',
        metavar = 'N',
        type    = int,
        default = DEFAULT_NUM_CONCATS,
        help    = 'number of (binary) concats to add (default: {})'.format(DEFAULT_NUM_CONCATS)
    )
    lengths_parser.add_argument(
        '--random-relations',
        '-r',
        action  = 'store_true',
        dest    = 'random_relations',
        default = DEFAULT_RANDOM_RELATIONS,
        help    = 'use constraints other than "=" (default: {!r})'.format(DEFAULT_RANDOM_RELATIONS)
    )

    # overlaps fuzzer
    overlaps_parser = subparsers.add_parser(OVERLAPS, help='instance with overlapping variables')
    overlaps_parser.add_argument(
        '--num-vars',
        '-n',
        dest    = 'num_vars',
        metavar = 'N',
        type    = int,
        default = DEFAULT_NUM_OVERLAPPING,
        help    = 'number of overlapping variables to generate (default: {})'.format(DEFAULT_NUM_OVERLAPPING)
    )
    overlaps_parser.add_argument(
        '--length-of-consts',
        '-c',
        dest    = 'length_of_consts',
        metavar = 'N',
        type    = int,
        default = DEFAULT_LENGTH_OF_CONSTS,
        help    = 'the length of the constant terms (default: {})'.format(DEFAULT_LENGTH_OF_CONSTS)
    )

    # regex-pair fuzzer
    regex_pair_parser = subparsers.add_parser(REGEX_PAIR, help='instance with two regexes')

    # random text fuzzer
    random_parser = subparsers.add_parser(RANDOM_TEXT, help='totally random text')
    random_parser.add_argument(
        '--length',
        '-l',
        dest    = 'length',
        metavar = 'L',
        type    = int,
        default = DEFAULT_LENGTH,
        help    = 'length of the text (default: {})'.format(DEFAULT_LENGTH)
    )

    # # random_ast fuzzer
    # random_ast_parser = subparsers.add_parser(RANDOM_AST, help='random but syntactically valid problem')

    # parse args
    args = global_parser.parse_args()

    # get the generator function based on args
    generator_name = args.generator
    generator      = GENERATORS[generator_name]

    # seed the RNG
    if args.random is True:
        random.seed()
    else:
        random.seed(args.seed)

    # get some flags that will get popped from args before they're used
    produce_models = args.produce_models
    language       = args.language

    # get args as a dict
    # NOTE:
    #      argparse's Namespace object (which 'args' is) returns itself as a
    #      dict when vars() is called on it
    generator_args = vars(args)

    # pop arguments that are specific to this script because
    # they shouldn't be passed on to the generator
    generator_args.pop('language')
    generator_args.pop('produce_models')
    generator_args.pop('generator')
    generator_args.pop('seed')
    generator_args.pop('random')

    # run the generator with the args
    generated = generator(**generator_args)

    # the random text generator produces raw text
    if (generator == random_text):
        print(generated)

    # other generators produce ASTs
    else:

        # add the model-getting node if needed
        if produce_models is True:
            generated.append(smt_model())

        print(generate(generated, language))

if __name__ == '__main__':
    main()
