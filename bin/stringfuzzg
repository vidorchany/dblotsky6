#!/usr/bin/env python3

'''
The fuzzer tool that generates new problems.
'''

import sys
import argparse
import random

from stringfuzz.constants import LANGUAGES, SMT_20_STRING, SMT_25_STRING
from stringfuzz.parser import parse
from stringfuzz.generators import concats, random_text, random_ast, SYNTACTIC_DEPTH, SEMANTIC_DEPTH

# constants
CONCATS     = 'concats'
RANDOM_TEXT = 'random-text'
RANDOM_AST  = 'random-ast'

GENERATORS = {
    CONCATS:     concats,
    RANDOM_TEXT: random_text,
    RANDOM_AST:  random_ast
}

DEPTH_TYPES = [SYNTACTIC_DEPTH, SEMANTIC_DEPTH]

# defaults
DEFAULT_SEED = 0

DEFAULT_LENGTH        = 10
DEFAULT_DEPTH         = 5
DEFAULT_SOLUTION      = None
DEFAULT_BALANCED      = False
DEFAULT_DEPTH_TYPE    = SYNTACTIC_DEPTH
DEFAULT_EXTRACTED     = 0
DEFAULT_EXTRACT_INDEX = 10

def main():

    # create arg parser
    parser = argparse.ArgumentParser(description='SMTLIB 2.* problem generator.')
    parser.add_argument(
        '--language',
        '-l',
        dest    = 'language',
        type    = str,
        choices = LANGUAGES,
        default = SMT_25_STRING,
        help    = 'output language (default: {})'.format(SMT_25_STRING)
    )
    parser.add_argument(
        '--seed',
        '-r',
        dest    = 'seed',
        metavar = 'S',
        type    = int,
        default = DEFAULT_SEED,
        help    = 'seed for random number generator (default: {})'.format(DEFAULT_SEED)
    )

    # get subparsers
    subparsers = parser.add_subparsers(dest='generator', help='generator choice')
    subparsers.required = True

    # concats fuzzer
    concats_parser = subparsers.add_parser(CONCATS, help='instance with deeply nested concats')
    concats_parser.add_argument(
        '--depth',
        '-d',
        dest    = 'depth',
        metavar = 'D',
        type    = int,
        default = DEFAULT_DEPTH,
        help    = 'depth of the concats (default: {})'.format(DEFAULT_DEPTH)
    )
    concats_parser.add_argument(
        '--depth-type',
        '-t',
        dest    = 'depth_type',
        type    = str,
        choices = DEPTH_TYPES,
        default = DEFAULT_DEPTH_TYPE,
        help    = 'type of depth (default: {})'.format(DEFAULT_DEPTH_TYPE)
    )
    concats_parser.add_argument(
        '--solution',
        '-s',
        dest    = 'solution',
        metavar = 'S',
        type    = str,
        default = DEFAULT_SOLUTION,
        help    = 'expected solution (default: {!r})'.format(DEFAULT_SOLUTION)
    )
    concats_parser.add_argument(
        '--extract',
        '-e',
        dest    = 'num_extracts',
        metavar = 'N',
        type    = int,
        default = DEFAULT_EXTRACTED,
        help    = 'number of extracts to add (default: {})'.format(DEFAULT_EXTRACTED)
    )
    concats_parser.add_argument(
        '--extract-max',
        '-m',
        dest    = 'max_extract_index',
        metavar = 'N',
        type    = int,
        default = DEFAULT_EXTRACT_INDEX,
        help    = 'max index from which to extract (default: {})'.format(DEFAULT_EXTRACT_INDEX)
    )
    concats_parser.add_argument(
        '--balanced',
        '-b',
        action  = 'store_true',
        default = DEFAULT_BALANCED,
        help    = 'flag for balanced tree (default: {!r})'.format(DEFAULT_BALANCED)
    )

    # random text fuzzer
    random_parser = subparsers.add_parser(RANDOM_TEXT, help='totally random text')
    random_parser.add_argument(
        '--length',
        '-l',
        dest    = 'length',
        metavar = 'L',
        type    = int,
        default = DEFAULT_LENGTH,
        help    = 'length of the text (default: {})'.format(DEFAULT_LENGTH)
    )

    # # random_ast fuzzer
    # random_ast_parser = subparsers.add_parser(RANDOM_AST, help='random but syntactically valid problem')

    # parse args
    args = parser.parse_args()

    # get the generator function based on args
    generator_name = args.generator
    generator      = GENERATORS[generator_name]

    # seed the RNG
    random.seed(args.seed)

    # get args as a dict
    # NOTE:
    #      argparse's Namespace object (which 'args' is) returns itself as a
    #      dict when vars() is called on it
    generator_args = vars(args)

    # pop arguments that shouldn't be passed on to the generator
    generator_args.pop('generator')
    generator_args.pop('seed')

    # run the generator with the args
    print(generator(**generator_args))

if __name__ == '__main__':
    main()
