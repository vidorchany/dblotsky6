#!/usr/bin/env python3

'''
The fuzzer tool that generates new problems.
'''

import sys
import argparse

from stringfuzz.constants import LANGUAGES, SMT_20_STRING, SMT_25_STRING
from stringfuzz.parser import parse
from stringfuzz.generators import concats, random_text, random_ast, SYNTACTIC_DEPTH, SEMANTIC_DEPTH

# constants
CONCATS     = 'concats'
RANDOM_TEXT = 'random-text'
RANDOM_AST  = 'random-ast'

GENERATORS = {
    CONCATS:     concats,
    RANDOM_TEXT: random_text,
    RANDOM_AST:  random_ast
}

DEPTH_TYPES = [SYNTACTIC_DEPTH, SEMANTIC_DEPTH]

# defaults
DEFAULT_LENGTH     = 10
DEFAULT_DEPTH      = 5
DEFAULT_SOLUTION   = 'solution'
DEFAULT_BALANCED    = False
DEFAULT_DEPTH_TYPE = SYNTACTIC_DEPTH

def main():

    # create arg parser
    parser = argparse.ArgumentParser(description='SMTLIB 2.* problem generator.')
    parser.add_argument(
        '--language',
        '-l',
        dest    = 'language',
        type    = str,
        choices = LANGUAGES,
        default = SMT_25_STRING,
        help    = 'output language (default: {})'.format(SMT_25_STRING)
    )

    # get subparsers
    subparsers = parser.add_subparsers(dest='generator', help='generator choice')
    subparsers.required = True

    # concats fuzzer
    concats_parser = subparsers.add_parser(CONCATS, help='instance with deeply nested concats')
    concats_parser.add_argument(
        '--depth',
        '-d',
        dest    = 'depth',
        metavar = 'D',
        type    = int,
        default = DEFAULT_DEPTH,
        help    = 'depth of the concats (default: {})'.format(DEFAULT_DEPTH)
    )
    concats_parser.add_argument(
        '--depth-type',
        '-t',
        dest    = 'depth_type',
        type    = str,
        choices = DEPTH_TYPES,
        default = DEFAULT_DEPTH_TYPE,
        help    = 'type of depth (default: {})'.format(DEFAULT_DEPTH_TYPE)
    )
    concats_parser.add_argument(
        '--solution',
        '-s',
        dest    = 'solution',
        metavar = 'S',
        type    = str,
        default = DEFAULT_SOLUTION,
        help    = 'expected solution (default: {!r})'.format(DEFAULT_SOLUTION)
    )
    concats_parser.add_argument(
        '--balanced',
        '-b',
        action  = 'store_true',
        default = DEFAULT_BALANCED,
        help    = 'flag for balanced tree (default: {!r})'.format(DEFAULT_BALANCED)
    )

    # random text fuzzer
    random_parser = subparsers.add_parser(RANDOM_TEXT, help='totally random text')
    random_parser.add_argument(
        '--length',
        '-l',
        dest    = 'length',
        metavar = 'L',
        type    = int,
        default = DEFAULT_LENGTH,
        help    = 'length of the text (default: {})'.format(DEFAULT_LENGTH)
    )

    # # random_ast fuzzer
    # random_ast_parser = subparsers.add_parser(RANDOM_AST, help='random but syntactically valid problem')

    # parse args
    args = parser.parse_args()

    # get the generator function based on args
    generator_name = args.generator
    generator      = GENERATORS[generator_name]

    # get args as a dict
    # NOTE:
    #      argparse's Namespace object (which 'args' is) returns itself as a
    #      dict when vars() is called on it
    generator_args = vars(args)

    # NOTE:
    #      the returned dict still has the 'generator' key because we
    #      added it during the call to add_subparsers(), so we remove it here
    generator_args.pop('generator')

    # run the generator with the args
    print(generator(**generator_args))

if __name__ == '__main__':
    main()
